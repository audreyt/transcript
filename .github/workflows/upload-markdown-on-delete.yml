name: Upload markdown on delete

on:
  push:
    paths:
      - "*.md"

jobs:
  notify-deleted-markdown:
    runs-on: ubuntu-latest
    env:
      API_ENDPOINT: https://dev.archive.tw/api/upload_markdown
      AUDREYT_TRANSCRIPT_TOKEN: ${{ secrets.AUDREYT_TRANSCRIPT_TOKEN }}
      BESTIAN_TRANSCRIPT_TOKEN: ${{ secrets.BESTIAN_TRANSCRIPT_TOKEN }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Resolve token
        id: token
        shell: bash
        run: |
          if [ -n "${AUDREYT_TRANSCRIPT_TOKEN}" ]; then
            echo "value=${AUDREYT_TRANSCRIPT_TOKEN}" >> "${GITHUB_OUTPUT}"
          elif [ -n "${BESTIAN_TRANSCRIPT_TOKEN}" ]; then
            echo "value=${BESTIAN_TRANSCRIPT_TOKEN}" >> "${GITHUB_OUTPUT}"
          else
            echo "Neither AUDREYT_TRANSCRIPT_TOKEN nor BESTIAN_TRANSCRIPT_TOKEN is set." >&2
            exit 1
          fi

      - name: DELETE removed markdown files
        env:
          TOKEN: ${{ steps.token.outputs.value }}
        shell: bash
        run: |
          python3 - <<'PY'
          import json
          import os
          import pathlib
          import subprocess
          import sys
          import urllib.error
          import urllib.request

          endpoint = os.environ["API_ENDPOINT"]
          token = os.environ["TOKEN"]
          before_sha = os.environ.get("GITHUB_EVENT_BEFORE", "")
          after_sha = os.environ.get("GITHUB_SHA", "")
          event_name = os.environ.get("GITHUB_EVENT_NAME", "")
          ref_name = os.environ.get("GITHUB_REF_NAME", "")

          print(f"[debug] event={event_name} ref={ref_name}")
          print(f"[debug] before={before_sha}")
          print(f"[debug] after={after_sha}")

          if before_sha and before_sha != ("0" * 40):
            cmd = ["git", "diff", "--name-status", before_sha, after_sha]
          else:
            # Fallback for the first push where "before" can be all zeros.
            cmd = ["git", "show", "--name-status", "--pretty=format:", after_sha]

          print(f"[debug] cmd={' '.join(cmd)}")
          diff_output = subprocess.check_output(cmd, text=True)
          print("[debug] raw diff output:")
          print(diff_output if diff_output.strip() else "(empty)")

          removed_files = []
          for line in diff_output.splitlines():
            if not line.strip():
              continue
            parts = line.split("\t")
            status = parts[0]
            if not status.startswith("D") or len(parts) < 2:
              continue
            rel_path = parts[-1]
            p = pathlib.Path(rel_path)
            if p.suffix == ".md" and len(p.parts) == 1:
              removed_files.append(rel_path)

          # Keep order while removing duplicates.
          unique_removed_files = list(dict.fromkeys(removed_files))
          print(f"[debug] removed root md files={unique_removed_files}")
          if not unique_removed_files:
            print("No root-level removed markdown files detected.")
            sys.exit(0)

          for rel_path in unique_removed_files:
            payload = {
              "filename": rel_path,
            }
            data = json.dumps(payload, ensure_ascii=False).encode("utf-8")
            req = urllib.request.Request(
              endpoint,
              data=data,
              method="DELETE",
              headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json; charset=utf-8",
              },
            )

            try:
              with urllib.request.urlopen(req) as resp:
                body = resp.read().decode("utf-8", errors="replace")
                print(f"DELETE {rel_path} -> HTTP {resp.status}")
                print(body)
            except urllib.error.HTTPError as e:
              body = e.read().decode("utf-8", errors="replace")
              print(f"DELETE {rel_path} failed -> HTTP {e.code}")
              print(body)
              raise
          PY
